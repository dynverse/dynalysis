---
title: "Supplementary Note: Trajectory Inference Wrappers"
bibliography: ../references.bib
csl: ../nature-biotechnology.csl
header-includes:
  - \usepackage{booktabs}
  - \usepackage{longtable}
  - \usepackage{array}
  - \usepackage{multirow}
  - \usepackage[table]{xcolor}
  - \usepackage{float}
  - \usepackage{colortbl}
  - \usepackage{tabu}
  - \usepackage[normalem]{ulem}
  - \usepackage{lscape}
  - \usepackage{pbox}
  - \usepackage[labelformat=empty]{caption}
  - \ExecuteBibliographyOptions{sorting=none,sortcites=true,autocite=superscript,autopunct=false}
mainfont: Open Sans
output: 
  pdf_document: 
    citation_package: biblatex
    fig_height: 6
    fig_width: 10
    keep_tex: yes
    latex_engine: xelatex
    toc: yes
editor_options: 
  chunk_output_type: console
---



```{r setup, include=FALSE}
# knitr options
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  out.width = "0.5\\textwidth",
  fig.align = "center",
  fig.path = paste0(rprojroot::find_rstudio_root_file(), "/analysis/paper/supp_notes/.scratch/")
)


# load libraries
library(dynalysis)
library(dynplot)
library(tidyverse)
library(cowplot)
```


# `aga`: AGA
<insert description AGA>

## Parameters

```{r}
method <- description_aga()
par_set <- method$par_set
par_set
```

The default parameters are the following:
```{r}
defprm <- ParamHelpers::dfRowToList(
  ParamHelpers::generateDesignOfDefaults(par_set, trafo = TRUE),
  par_set, 
  i = 1
)
defprm
```

## Example dataset
We will be using a consecutive bifurcating toy dataset to demonstrate this method with.

```{r}
toy <- dyntoy::toy_tasks %>% filter(model == "consecutive_bifurcating") %>% extract_row_to_list(row_id = 1)
expression <- toy$expression

plot_default(toy)
```

## Wrapper

Since AGA is implemented in Python, we created an R package for it. 
```{r}
aga_out <- aga::aga(
  counts = expression,
  start_cell = NULL,
  grouping_assignment = NULL,
  n_neighbours = defprm$n_neighbours,
  n_pcs = defprm$n_pcs,
  n_dcs = defprm$n_dcs,
  resolution = defprm$resolution,
  tree_based_confidence = defprm$tree_based_confidence,
  verbose = FALSE,
  num_cores = 1
)
```

<Talk about aga_out$adj>
```{r}
aga_out$adj %>% head(6) %>% knitr::kable()
```

<Talk about aga_out$obs>
```{r}
aga_out$obs %>% head(6) %>% knitr::kable()
```

Reformat everything into milestone_network and milestone_percentages
```{r}
cell_ids <- rownames(expression)

milestone_assignment_cells <- setNames(aga_out$obs$group_id, aga_out$obs$cell_id)

milestone_network <- aga_out$adj %>%
  mutate_at(vars(from, to), as.character) %>%
  filter(aga_adjacency_tree_confidence > 0) %>%
  mutate(
    length = 1,
    directed = TRUE
  ) %>%
  select(from, to, length, directed)

milestone_ids <- sort(unique(milestone_assignment_cells))
```


The prediction is wrapped using the `add_trajectory_to_wrapper` function. 
```{r}
prediction <- wrap_prediction_model(
  cell_ids = rownames(expression)
) %>% add_cluster_graph_to_wrapper(
  milestone_ids = milestone_ids,
  milestone_network = milestone_network,
  milestone_assignment_cells = milestone_assignment_cells,
  aga_out = aga_out
)

plot_default(prediction)
method$plot_fun(prediction)
plot_strip_connections(toy, prediction)
```



# `atan`: Arc-tangent
This is a control method for inferring cyclic trajectories in a very simple approach,
consisting of a dimensionality reduction step and followed by calculating the arc-tangent
between the first and the second component.

## Parameters
There is only one parameter, namely the dimensionality reduction method used.
```{r}
method <- description_atan()
par_set <- method$par_set
par_set
```

The default parameters are the following:
```{r}
defprm <- ParamHelpers::dfRowToList(
  ParamHelpers::generateDesignOfDefaults(par_set, trafo = TRUE),
  par_set, 
  i = 1
)
defprm
```

## Example dataset
We will be using a cyclic toy dataset to demonstrate this method with.

```{r}
toy <- dyntoy::toy_tasks %>% filter(model == "cycle") %>% extract_row_to_list(row_id = 2)
expression <- toy$expression

plot_default(toy)
```

## Wrapper
In the first step, a dimensionality reduction to two dimensions is computed. By default, this is PCA. 
Here, it is assumed that the dimensionality reduction will be centered around the origin 0.

```{r}
dimred <- dynmethods:::dimred(expression, method = defprm$dimred, ndim = 2)

# Plot dimred
dimred_df <- data.frame(dimred) %>% rownames_to_column("cell_id")
ggplot(dimred_df) + geom_point(aes(Comp1, Comp2)) + coord_equal()

```

The ordering of the cells is computed by calculating the bearing of each cell with respect to the origin. The bearing is transformed to a [0,1] range.

```{r}
pseudotimes <- atan2(dimred[,2], dimred[,1]) / 2 / pi + .5

dimred_df <- dimred_df %>% mutate(pseudotime = pseudotimes[cell_id])
ggplot(dimred_df) +
  geom_point(aes(Comp1, Comp2, colour = pseudotime)) +
  coord_equal() + 
  viridis::scale_color_viridis()
```

The prediction is wrapped using the `add_cycling_trajectory_to_wrapper` function. 
```{r}
prediction <- wrap_prediction_model(
  cell_ids = rownames(expression)
) %>% add_cyclic_trajectory_to_wrapper(
  pseudotimes = pseudotimes,
  do_scale_minmax = FALSE
) %>% add_dimred_to_wrapper(
  dimred = dimred
)

plot_default(prediction)
method$plot_fun(prediction)
plot_strip_connections(toy, prediction)
```


# Colophon
This report was generated on `r Sys.time()` using `r devtools:::platform_info()$version` and the following packages:
```{r colophon, cache = FALSE}
devtools::session_info()$packages %>% knitr::kable()
```
