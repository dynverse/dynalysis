---
title: "Supplementary Note: Trajectory Inference Wrappers"
bibliography: ../references.bib
csl: ../nature-biotechnology.csl
header-includes:
  - \usepackage{booktabs}
  - \usepackage{longtable}
  - \usepackage{array}
  - \usepackage{multirow}
  - \usepackage[table]{xcolor}
  - \usepackage{float}
  - \usepackage{colortbl}
  - \usepackage{tabu}
  - \usepackage[normalem]{ulem}
  - \usepackage{lscape}
  - \usepackage{pbox}
  - \usepackage[labelformat=empty]{caption}
  - \ExecuteBibliographyOptions{sorting=none,sortcites=true,autocite=superscript,autopunct=false}
mainfont: Open Sans
output: 
  pdf_document: 
    citation_package: biblatex
    fig_height: 6
    fig_width: 10
    keep_tex: yes
    latex_engine: xelatex
    toc: yes
editor_options: 
  chunk_output_type: console
---



```{r setup, include=FALSE}
# knitr options
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  out.width = "0.5\\textwidth",
  fig.align = "center",
  fig.path = paste0(rprojroot::find_rstudio_root_file(), "/analysis/paper/supp_notes/.scratch/")
)

source(paste0(dynalysis::get_dynalysis_folder(), "/analysis/paper/setup.R"))
```

This document serves to provide insight into how each trajectory inference method was used and wrapped.



```{r}
library(dynmethods)
library(dynwrap)
library(dynutils)
library(dynplot)
```



<!-- ################################################## aga ################################################## -->
See [https://github.com/dynverse/dynmethods/blob/master/vignettes/aga.Rmd](dynmethods).


<!-- ################################################## agapt ################################################## -->

# `agapt`: AGA pseudotime
TODO: move to dynmethods.

When a start cell is given, AGA supports ordering the cells along branches.

## Parameters
```{r}
method <- description_agapt()
method$par_set
```


## Example dataset
We will be using the same consecutive bifurcating toy dataset.

```{r}
toy <- dyntoy::toy_tasks %>% 
  filter(model == "consecutive_bifurcating") %>% 
  extract_row_to_list(row_id = 1)
expression <- toy$expression
start_cells <- toy$prior_information$start_cells

plot_default(toy)
```


## Wrapper

Since AGA is implemented in Python, we created an R package for it, available at [github.com/dynverse/aga](https://github.com/dynverse/aga).
The R package will write the expression values and any parameters to a file, execute a python script, and read the results from output files produced by AGA.
```{r}
defprm <- get_default_parameters(method)

# sample one start cell
start_cell <- sample(start_cells, 1)

aga_out <- aga::aga(
  expression = expression,
  start_cell = start_cell,
  grouping_assignment = NULL,
  n_neighbours = defprm$n_neighbours,
  n_pcs = defprm$n_pcs,
  n_dcs = defprm$n_dcs,
  resolution = defprm$resolution,
  tree_based_confidence = defprm$tree_based_confidence,
  verbose = TRUE,
  num_cores = 1
)
```

After building a kNN graph (not shown), the kNN graph is clustered into louvain groups:
```{r}
aga_out$obs %>% head(6) %>% knitr::kable()

# cell_ids <- rownames(expression)
# milestone_assignment_cells <- setNames(aga_out$obs$group_id, aga_out$obs$cell_id)
```

Several tests are used to assess which transitions exist between the louvain groups. 
We use the `aga_adjacency_tree_confidence` to construct the milestone network.
```{r}
aga_out$adj %>% head(6) %>% knitr::kable()
```


<!-- ################################################## atan ################################################## -->

# `atan`: Arc-tangent
TODO: move to dynmethods.

This is a control method for inferring cyclic trajectories in a very simple approach,
consisting of a dimensionality reduction step and followed by calculating the arc-tangent
between the first and the second component.


## Parameters
```{r}
method <- description_atan()
method$par_set
```

## Example dataset
We will be using a cyclic toy dataset to demonstrate this method with.

```{r}
toy <- dyntoy::toy_tasks %>% 
  filter(model == "cycle") %>% 
  extract_row_to_list(row_id = 2)
expression <- toy$expression

plot_default(toy)
```

## Wrapper
In the first step, a dimensionality reduction to two dimensions is computed. By default, this is PCA. 
Here, it is assumed that the dimensionality reduction will be centered around the origin 0.

```{r}
defprm <- get_default_parameters(method)

dimred <- dynmethods:::dimred(expression, method = defprm$dimred, ndim = 2)

# Plot dimred
dimred_df <- data.frame(dimred) %>% rownames_to_column("cell_id")
ggplot(dimred_df) + geom_point(aes(Comp1, Comp2)) + coord_equal()

```

The ordering of the cells is computed by calculating the bearing of each cell with respect to the origin. The bearing is transformed to a [0,1] range.

```{r}
pseudotimes <- atan2(dimred[,2], dimred[,1]) / 2 / pi + .5

dimred_df <- dimred_df %>% mutate(pseudotime = pseudotimes[cell_id])
ggplot(dimred_df) +
  geom_point(aes(Comp1, Comp2, colour = pseudotime)) +
  coord_equal() + 
  viridis::scale_color_viridis()
```

The prediction is wrapped using the `add_cycling_trajectory_to_wrapper` function. 
```{r}
prediction <- wrap_prediction_model(
  cell_ids = rownames(expression)
) %>% add_cyclic_trajectory_to_wrapper(
  pseudotimes = pseudotimes,
  do_scale_minmax = FALSE
) %>% add_dimred_to_wrapper(
  dimred = dimred
)

plot_default(prediction)
method$plot_fun(prediction)
plot_strip_connections(toy, prediction)
```


# Colophon
This report was generated on `r Sys.time()` using `r devtools:::platform_info()$version` and the following packages:
```{r colophon, cache = FALSE}
devtools::session_info()$packages %>% knitr::kable()
```
